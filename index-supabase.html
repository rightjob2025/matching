import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.0.0"

const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req: Request) => {
    if (req.method === 'OPTIONS') {
        return new Response('ok', { headers: corsHeaders })
    }

    try {
        const { user, jobs } = await req.json()
        const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')
        const SUPABASE_URL = Deno.env.get('SUPABASE_URL')
        const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

        if (!GEMINI_API_KEY || !SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
            throw new Error('Missing environment variables')
        }

        const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

        // プロンプトの取得戦略: master_data (組織設定) > system_prompts (システムデフォルト) > ハードコード
        const organizationId = user.organization_id;

        // 1. System Prompts
        const { data: systemPrompts } = await supabaseAdmin
            .from('system_prompts')
            .select('*')
            .in('key', ['ai_matching_scoring', 'ai_recommendation_reason'])

        // 2. Organization Prompts (master_data)
        let orgPrompts: any[] = [];
        if (organizationId) {
            const { data: ops, error: opError } = await supabaseAdmin
                .from('master_data')
                .select('*')
                .eq('organization_id', organizationId)
                .eq('type', 'prompt')
                .in('value', ['ai_matching_scoring', 'ai_recommendation_reason'])

            if (!opError && ops) {
                orgPrompts = ops;
            }
        }

        // Helper
        function decodeContent(str: string): string {
            if (!str) return '';
            try {
                const binaryString = atob(str);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder().decode(bytes);
            } catch (e) {
                return str;
            }
        }

        let scoringPromptTemplate = ''
        let reasonPromptTemplate = ''

        // Scoring Prompt OK?
        const orgScoring = orgPrompts.find((p: any) => p.value === 'ai_matching_scoring');
        if (orgScoring && orgScoring.label) {
            scoringPromptTemplate = decodeContent(orgScoring.label);
        } else {
            const sysScoring = systemPrompts?.find((p: any) => p.key === 'ai_scoring_strict_prompt');
            if (sysScoring) scoringPromptTemplate = decodeContent(sysScoring.content);
        }

        // Reason Prompt OK?
        const orgReason = orgPrompts.find((p: any) => p.value === 'ai_recommendation_reason');
        if (orgReason && orgReason.label) {
            reasonPromptTemplate = decodeContent(orgReason.label);
        }

        if (!scoringPromptTemplate) {
            scoringPromptTemplate = `
あなたは経験豊富なキャリアアドバイザーおよび組織文化の専門家です。
第1段階の基本条件（年収・勤務地）をクリアした求人について、以下の手順で厳密に評価してください。

【重要：外部情報の活用】
提示された「求人情報」や「企業文化」の情報が不足していると感じた場合は、**Google検索を使用して企業の最新情報、ビジョン、社員の口コミ評価（OpenWork等）、テックブログなどを自律的に調査補完**し、より精度の高いカルチャー診断を行ってください。

【第2段階：スキル・経歴マッチ度スコアリング】
求職者の経歴と求人の業務内容・必須要件を比較し、0〜100点でスコアリングしてください。
- 必須要件（Must）を満たしていない、または確認できない場合は、必ず **49点以下** にしてください。
- 50点以上の評価は、必須要件をクリアしている場合に限ります。

【第3段階：社風・カルチャーマッチ度スコアリング】
上記スキルマッチスコアが **50点以上** の場合のみ、企業の社風と個人の志向性を診断してください。
- **補完した外部情報（検索結果）も加味して判断してください。**
- スキルスコアが49点以下の場合は、カルチャー評価を「判定不能（-）」としてください。
- 評価ランク: A(最高) / B / C / D / E(最低) / -(判定不能)
- 職種特性（例：事務職なら営業ノルマの影響は少ない等）も考慮してください。

【出力形式の制限（絶対遵守）】
マークダウン記号は使用せず、以下の形式でプレーンテキストのみ出力してください。

マッチ度評価
評価: [A〜Eランク]
理由: [100文字以内。必須要件の充足状況やスキル適合度を簡潔に]
総合評価: [数値 0-100]点

社風・カルチャーのフィット度評価
評価: [A〜Eランク または -]
理由: [100文字以内。50点未満の場合は「スキル要件未達のため判定スキップ」と記述。検索情報を用いた場合はその旨も含めて可]

【求職者情報】
- 氏名: \${userData.name}
- 職務経歴書（詳細）: \${userData.work_history}
- 経歴要約・プロフィール: \${userData.profile_summary}
- スキル・PR・備考: \${userData.notes}
- 社内共有情報（コーチングメモ）: \${userData.internal_info}
- 社内マッチング特記事項: \${userData.matching_info}
- その他補足（資格等）: \${userData.other_info}
- 年齢/属性: \${userData.age}

【求人情報】
- 企業名: \${jobDetails.company}
- 職種: \${jobDetails.title}
- 業種: \${jobDetails.industrycategory}
- 業務内容: \${jobDetails.description}
- 応募資格（必須スキル）: \${jobDetails.qualifications}
- 企業文化・特徴: \${jobDetails.company_info}
`;
        }

        if (!reasonPromptTemplate) {
            reasonPromptTemplate = scoringPromptTemplate; // 同じ温かいトーンのプロンプトを使用するように統一
        }

        // 各求人に対して処理
        const promises = jobs.map(async (job) => {
            // 第1段階: ルールベースによる必須条件フィルタリング
            // 年収チェック (求人の最大年収 < 希望年収 ならNG)
            if (user.desired_salary && job.salary_max && (job.salary_max * 10000) < user.desired_salary) {
                return {
                    job_id: job.id,
                    match_score: 10,
                    culture_match_score: 0,
                    reason: `希望年収（${Math.floor(user.desired_salary / 10000)}万円）に対し、求人の上限年収（${job.salary_max}万円）が下回っているため、AI判定前に除外されました。`,
                    recommendation_reason: `基本条件不一致: 希望年収を満たしていません (求人上限: ${job.salary_max}万円)`
                };
            }

            // 勤務地チェック (希望勤務地が設定されている場合のみ)
            if (user.desired_location && user.desired_location.length > 0 && job.location) {
                // 配列またはカンマ区切り文字列に対応
                const desiredLocs = Array.isArray(user.desired_location)
                    ? user.desired_location
                    : user.desired_location.split(',').map((s: string) => s.trim());

                // 求人の勤務地に、希望勤務地のいずれかが含まれているか (部分一致)
                // 例: 求人「東京都港区」 vs 希望「東京」 -> OK
                const locationMatch = desiredLocs.some((loc: string) => job.location.includes(loc));

                if (!locationMatch) {
                    return {
                        job_id: job.id,
                        match_score: 10,
                        culture_match_score: 0,
                        reason: `勤務地（${job.location}）が希望勤務地（${desiredLocs.join(', ')}）に含まれていないため、AI判定前に除外されました。`,
                        recommendation_reason: `基本条件不一致: 勤務地が希望条件と異なります`
                    };
                }
            }

            // --- 第1段階クリア：AI判定へ進む ---

            // 理由プロンプト（詳細な方）を統合プロンプトとして使用
            const prompt = replacePlaceholders(scoringPromptTemplate, job, user)


            try {
                // Gemini API呼び出し（1回に集約）
                const resultText = await callGemini(GEMINI_API_KEY, prompt)

                // その1つの結果からスコアとテキストの両方を抽出
                const parsedResult = parseScoringResult(resultText)

                return {
                    job_id: job.id,
                    ...parsedResult,
                    // 理由（UIへの表示用）はクリーニング済みのテキストを使用
                    recommendation_reason: parsedResult.details
                }
            } catch (e) {
                console.error(`Error processing job ${job.id}:`, e)
                return {
                    job_id: job.id,
                    error: e.message
                }
            }
        })

        const results = await Promise.all(promises)

        return new Response(JSON.stringify(results), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })

    } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        })
    }
})

function replacePlaceholders(template: string, job: any, user: any): string {
    const jobDetails: any = {
        company: job.companies?.name || job.company || '',
        title: job.title || '',
        industrycategory: job.industry_category || '',
        jobcategory: job.job_category || '',
        salary: `${job.salary_min || 0}万円 - ${job.salary_max || 0}万円`,
        location: job.location || '',
        employment_type: job.employment_type || '',
        description: job.description || '',
        qualifications: job.requirements || '',
        company_info: job.companies?.description || ''
    }

    // 職務経歴の構造化データをテキスト形式に変換して結合
    let workHistoryText = [user.work_history, user.work_history_detail].filter(Boolean).join('\n\n');
    if (user.work_history_structured && Array.isArray(user.work_history_structured)) {
        const structuredText = user.work_history_structured.map((w: any) => {
            return `【企業名】${w.company || w.companyName || ''}\n` +
                `【期間】${w.period || ''}\n` +
                `【役職】${w.position || ''}\n` +
                `【業務内容】\n${w.description || ''}`;
        }).join('\n\n----------------\n\n');

        if (structuredText) {
            workHistoryText += `\n\n【詳細職務経歴 (構造化データ)】\n${structuredText}`;
        }
    }

    let notesContent = [user.skills, user.self_pr, user.bio, user.desired_freewords].filter(Boolean).join('\n');
    if (!notesContent || notesContent.trim() === '') {
        notesContent = '特になし';
    }

    const userData: any = {
        name: user.name || '',
        notes: notesContent,
        resume: user.work_history_detail || 'あり', // 職務経歴詳細、または要約
        work_history: workHistoryText,
        age: user.age || (user.birthday || user.date_of_birth || user.birth_date ? calculateAge(user.birthday || user.date_of_birth || user.birth_date) : '') || '',
        skills: user.skills || '',
        desired_industry: user.desired_industry || '',
        desired_job_type: user.desired_job_type || '',
        desired_salary: user.desired_salary ? `${Math.floor(user.desired_salary / 10000)}万円` : '',
        desired_location: user.desired_location || '',
        matching_info: user.resume || '', // App uses .resume for internal matching info
        internal_info: user.notes || '',  // App uses .notes for internal notes
        other_info: [user.history_info, user.education, user.certifications, user.languages].filter(Boolean).join('\n'),
        profile_summary: user.bio || user.profile_summary || (workHistoryText ? workHistoryText.substring(0, 500) : '') || '',
        education: user.education || '',
        certifications: user.certifications || '',
        languages: user.languages || '',
        current_salary: user.current_salary ? `${Math.floor(user.current_salary / 10000)}万円` : ''
    }

    const userProfile: any = {
        desired_job_experience_ok: user.desired_job_experience_ok,
        desired_industry_experience_ok: user.desired_industry_experience_ok
    }

    return template.replace(/\$\{(.*?)\}/g, (match, p1) => {
        const expr = p1.trim()

        if (expr.match(/^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$/)) {
            const [objName, propName] = expr.split('.')
            if (objName === 'jobDetails') return String(jobDetails[propName] || '')
            if (objName === 'userData') return String(userData[propName] || '')
            return ''
        }

        if (expr.match(/^[a-zA-Z0-9_]+$/)) {
            if (userData[expr] !== undefined) return String(userData[expr]);
            if (jobDetails[expr] !== undefined) return String(jobDetails[expr]);
        }

        if (expr.includes('||')) {
            const [left, right] = expr.split('||').map(s => s.trim())
            const [objName, propName] = left.split('.')
            let val: any = ''
            if (objName === 'jobDetails') val = jobDetails[propName]
            else if (objName === 'userData') val = userData[propName]

            if (val !== undefined && val !== null && val !== '') return String(val)
            return right.replace(/['"]/g, '')
        }

        if (expr.includes('?') && expr.includes(':')) {
            const [condition, rest] = expr.split('?')
            const [trueVal, falseVal] = rest.split(':').map(s => s.trim().replace(/['"]/g, ''))
            const [objName, propName] = condition.trim().split('.')

            let val = false
            if (objName === 'userProfile') val = !!userProfile[propName]

            return val ? trueVal : falseVal
        }

        return ''
    })
}

async function callGemini(apiKey: string, prompt: string) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`
    const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            tools: [{ google_search: {} }], // Google Search Groundingを有効化
            generationConfig: { temperature: 0.2, maxOutputTokens: 8192 }
        })
    })

    if (!response.ok) {
        const errorData = await response.json()
        throw new Error(`Gemini API Error: ${JSON.stringify(errorData)}`)
    }

    const data = await response.json()
    return data.candidates[0].content.parts[0].text
}

function parseScoringResult(text: string) {
    // クリーニング: "マッチ度評価" より前のログ（tool_code等）を削除
    let cleanText = text;
    const headerIndex = text.indexOf('マッチ度評価');
    if (headerIndex !== -1) {
        cleanText = text.substring(headerIndex);
    }
    // tool_code, thought が残っている場合の念入りな削除
    cleanText = cleanText.replace(/tool_code[\s\S]*?print\(.*?\)/g, '')
        .replace(/thought\n[\s\S]*?(?=\n\n|\Z)/g, '') // thoughtブロックがあれば削除（改行で区切られていると仮定）
        .replace(/^```[\s\S]*?```/gm, '') // コードブロック除去
        .trim();

    const result = {
        culture_match_score: 0,
        match_score: 0,
        reason: '',
        details: cleanText // クリーニング済みのテキストを使用
    }

    // 1. 評価ランク (A-E) の抽出
    // マークダウンの '**A**' や '「A」' なども許容するため、キーワード後の [^A-E\n]* を追加
    const cultureMatch = cleanText.match(/(?:評価|ランク|フィット度|社風・カルチャーフィット|カルチャーランク)[^A-E\n]*([A-E])/)
    if (cultureMatch) {
        const grade = cultureMatch[1]
        const scores: any = { 'A': 95, 'B': 80, 'C': 60, 'D': 40, 'E': 20 }
        result.culture_match_score = scores[grade] || 50
    }

    // 2. 総合スコア (0-100) の抽出 - 強化版
    // パターンA: キーワードの後、改行を含んでも良いので数字を探す (最大50文字まで探索)
    let scoreMatch = cleanText.match(/(?:総合評価|総合マッチ度|マッチ度|スコア|適合度)[\s\S]{0,50}?(\d{1,3})[\s\S]{0,10}点/);

    // パターンB: キーワードが見つからない場合、単純に "XX点" という表記を探す
    if (!scoreMatch) {
        // 文末付近にある "85点" などを探す (配列の最後=文章の後ろの方を採用)
        const simpleScoreMatches = cleanText.match(/(\d{1,3})\s*点/g);
        if (simpleScoreMatches && simpleScoreMatches.length > 0) {
            const lastMatch = simpleScoreMatches[simpleScoreMatches.length - 1];
            const val = parseInt(lastMatch.replace(/[^0-9]/g, ''), 10);
            if (val <= 100) result.match_score = val;
        }
    } else {
        let val = parseInt(scoreMatch[1], 10)
        if (val > 100) val = 100
        result.match_score = val
    }

    // 3. 理由の抽出（文頭の「理由: 」など）
    const reasonMatch = cleanText.match(/理由[^:\n]*[:：]\s*([^\n]+)/)
    if (reasonMatch) {
        result.reason = reasonMatch[1].trim()
    }

    // スコアが取れなかった場合のフォールバック
    if (result.match_score === 0 && result.culture_match_score > 0) {
        result.match_score = result.culture_match_score;
    }

    return result
}

function calculateAge(birthday: string): number {
    if (!birthday) return 0;
    const birthDate = new Date(birthday);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const m = today.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
    }
    return age;
}
