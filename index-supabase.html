import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { text, type, options } = await req.json()
    const apiKey = Deno.env.get('GEMINI_API_KEY')
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not set')
    }

    let prompt = ''
    if (type === 'resume') {
      prompt = `
        以下の履歴書・職務経歴書のテキストから情報を抽出し、JSON形式で返してください。
        JSONのキーは以下のようにしてください:
        - skills (文字列): スキルセット
        - work_history (文字列): 職歴・自己PRの要約
        - work_history_structured (配列): 詳細な職歴リスト（最大10件）。新しい順に。各要素は以下のキーを持つオブジェクト:
          - company_name (文字列): 会社名
          - period (文字列): 在籍期間
          - industry (文字列): 所属企業の業種
          - job_category (文字列): 職種
          - role (文字列): 役割・役職
          - description (文字列): 職務内容
        - academic_background (文字列): 最終学歴
        - languages (文字列): 語学力
      Please analyze the following resume/job history document (text extracted from PDF) and extract the following information in JSON format:
      - Basic Profile (Name, Age, Address/Location, Education, Phone, Email)
      - Desired Conditions (Job Type, Industry, Location, Employment Type, Salary)
      - Skills (List of technical and soft skills)
      - Work History Summary (A concise summary of the candidate's career, suitable for a quick overview. Max 300 characters.)
      - Work History Detail Text (The full body text of the work history section, preserving the original content as much as possible, including self-promotion and detailed episodes.)
      - Job changes count (Calculate the total number of companies worked for based on the history. If uncertain, verify closely.)
      - Structured Work History (Extract ALL work history entries found in the document. Do not summarize or omit items. For each entry, provide as much detail as possible.)

      For the "Structured Work History", it is CRITICAL to capture the full details of each position. The "description" should include:
      - Specific projects and tasks performed.
      - Key achievements and results (numbers, awards, etc.).
      - Tools, technologies, and methodologies used.
      - Team size and role within the team.
      - Do not just write a brief summary; capture the richness of the experience.

      If the document is in Japanese, the output values should be in Japanese (except for keys).
      
      Output JSON format:
      {
        "name": "Name",
        "furigana": "Furigana (Katakana)",
        "age": 30, // number or null
        "address": "City, Prefecture only", 
        "education": "Final educational background",
        "phone": "090-0000-0000",
        "email": "example@email.com",
        "desired_job_type": ["Job Type 1", "Job Type 2"], // Array
        "desired_industry": ["Industry 1", "Industry 2"], // Array
        "desired_location": ["Location 1", "Location 2"], // Array of Prefectures/Cities
        "desired_employment_type": ["Full-time", "Contract"], // Array
        "desired_salary": 5000000, // number (annual salary in Yen) or null
        "skills": "Skill 1, Skill 2, ...", // single string
        "work_history": "Summary (short)...",
        "work_history_detail": "Full detail text...",
        "job_change_count": 2, // integer
        "work_history_structured": [
          {
            "company_name": "Company Name",
            "period": "YYYY/MM - YYYY/MM",
            "industry": "Industry",
            "job_category": "Job Category",
            "role": "Role/Position",
            "description": "Detailed description of responsibilities, projects, achievements, and tools used. Preserve line breaks if necessary for readability."
          }
        ]
      }
      
      テキスト: ${text}

      出力は必ず有効なJSON形式のみにしてください。Markdownのコードブロック（\`\`\`jsonなど）や、その他の説明文は一切含めないでください。
      `
    } else {
      const jobCategories = options?.job_categories ? `\n        - job_category (文字列): 職種カテゴリ。以下のリストから最も適切なものを選択してください: ${options.job_categories.join(', ')}` : '- job_category (文字列): 職種カテゴリ';
      const industryCategories = options?.industry_categories ? `\n        - industry_category (文字列): 業界カテゴリ。以下のリストから最も適切なものを選択してください: ${options.industry_categories.join(', ')}` : '- industry_category (文字列): 業界カテゴリ';

      prompt = `
        以下の求人票のテキストから情報を抽出し、JSON形式で返してください。
        
        【重要】「必須要件」と「歓迎条件（尚可）」が混在している場合、必ず整理して分割してください。
        - 必須条件、[必須]、■必須、などのキーワードがある箇所は「requirements」に。
        - 歓迎条件、尚可、[歓迎]、■歓迎、などのキーワードがある箇所は「welcome_requirements」に。
        - 明確な見出しがない場合でも、文脈から判断して適切に振り分けてください。
        - どちらか一方が空になる場合でも、もう一方にすべてを入れず、必ず内容を吟味して分割してください。

        JSONのキーは以下のようにしてください:
        - title (文字列): 求人タイトル
        - company (文字列): 会社名
        - location (文字列): 勤務地
        - salary_min (数値): 最低年収（単位：円。例：4000000）
        - salary_max (数値): 最高年収（単位：円。例：6000000）
        - description (文字列): 求人詳細（仕事内容のメインテキスト）
        - requirements (文字列): 必須要件（必須スキル・経験年数・資格など。箇条書きを推奨）
        - welcome_requirements (文字列): 尚可要件（歓迎スキル・あると望ましい経験など。箇条書きを推奨）
        - work_hours (文字列): 勤務時間
        - holidays (文字列): 休日休暇
        - benefits (文字列): 福利厚生
        - interview_process (文字列): 選考フロー
        - employment_type (文字列): 雇用形態
        - is_remote (真偽値): リモートワーク可否
        - job_experience_ok (真偽値): 職種未経験可否
        - industry_experience_ok (真偽値): 業界未経験可否${jobCategories}${industryCategories}
        
        テキスト: ${text}

        出力は必ず有効なJSON形式のみにしてください。Markdownのコードブロック（\`\`\`jsonなど）や、その他の説明文は一切含めないでください。
      `
    }

    // 利用可能なモデル一覧から 'gemini-2.5-flash-lite' を選択
    const model = 'gemini-2.5-flash-lite';
    const version = 'v1beta';
    const url = `https://generativelanguage.googleapis.com/${version}/models/${model}:generateContent?key=${apiKey}`;

    console.log(`Requesting ${url} for type ${type}`);

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
          responseMimeType: "application/json"
        }
      })
    })

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Gemini API Error (${model}):`, errorText);
      return new Response(JSON.stringify({
        error: `Gemini API returned status ${response.status}`,
        details: errorText
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const data = await response.json()

    if (!data.candidates || data.candidates.length === 0) {
      console.error('No candidates in Gemini response:', JSON.stringify(data));
      throw new Error('No response from AI (candidates array is empty)')
    }

    let jsonString = data.candidates[0].content.parts[0].text
    console.log('Gemini Response Raw:', jsonString);

    // Markdownコードブロックの除去
    jsonString = jsonString.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

    console.log('Gemini Response Cleaned:', jsonString);

    const result = JSON.parse(jsonString)

    return new Response(JSON.stringify(result), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })

  } catch (error: any) {
    console.error('Edge Function Error:', error);
    return new Response(JSON.stringify({
      error: error.message,
      stack: error.stack
    }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
})
